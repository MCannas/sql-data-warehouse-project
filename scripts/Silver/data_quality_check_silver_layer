--Build Silver Layer
--Clean & Load
--Loading and Quality Check of the Silver Table.
--Result: cleasing of the data before insert into the tables.

use master;
--GO;
USE DataWarehouse;
--GO;

--Loading the data after cleasing data from the bronze tables.

SELECT * FROM bronze.crm_prd_info

SELECT prd_id, count(*)
FROM bronze.crm_prd_info
GROUP BY prd_id
HAVING COUNT(*) > 1 OR prd_id IS NULL;


-- Extract the product key into different categories.
-- SUBSTRING()
-- Extracts a specific part of a string value.
-- First the cat_id from the first 5 characters.

SELECT prd_key, SUBSTRING(prd_key,1,5) AS cat_id
FROM bronze.crm_prd_info

SELECT prd_key, REPLACE(SUBSTRING(prd_key,1,5), '-', '_') AS cat_id
FROM bronze.crm_prd_info

-- Second check that the extracted bronze.crm_prd_info.cat_id equals the existing bronze.erp_px_cat_g1v2
-- Result: each row must match.
-- Check the value notation.
-- erp	   crm
-- CO_RF & CO-RF

-- Use a dynamic length extraction.
-- LEN()
-- Returns the number of characters in a string.

SELECT DISTINCT id FROM bronze.erp_px_cat_g1v2
WHERE id = 'CO_RF'

SELECT * FROM bronze.crm_sales_details

SELECT sls_prd_key FROM bronze.crm_sales_details

SELECT DISTINCT id 
FROM bronze.erp_px_cat_g1v2 t1, bronze.crm_prd_info t2
WHERE t1.ID = REPLACE(SUBSTRING(t2.prd_key,1,5), '-', '_')

-- Filters out unmatched data after applying transformation.

SELECT
	prd_id,
	prd_key,
	REPLACE(SUBSTRING(prd_key,1,5), '-', '_') AS cat_id,
	REPLACE(SUBSTRING(prd_key,7,LEN(prd_key)), '-', '_') AS prd_key,
	prd_nm,
	prd_cost,
	prd_line,
	prd_start_dt,
	prd_end_dt
FROM bronze.crm_prd_info
WHERE REPLACE(SUBSTRING(prd_key,1,5), '-', '_') NOT IN 
(SELECT DISTINCT id FROM bronze.erp_px_cat_g1v2)

-- Without a where-clause there are many without a product cost.
-- No results with the REPLACE command in the WHERE clause.
SELECT
	prd_id,
	prd_key,
	REPLACE(SUBSTRING(prd_key,1,5), '-', '_') AS cat_id,
	REPLACE(SUBSTRING(prd_key,7,LEN(prd_key)), '-', '_') AS prd_key,
	prd_nm,
	prd_cost,
	prd_line,
	prd_start_dt,
	prd_end_dt
FROM bronze.crm_prd_info
WHERE REPLACE(SUBSTRING(prd_key,7,LEN(prd_key)), '-', '_') NOT IN 
(SELECT sls_prd_key FROM bronze.crm_sales_details)


SELECT
	prd_id,
	prd_key,
	REPLACE(SUBSTRING(prd_key,1,5), '-', '_') AS cat_id,
	REPLACE(SUBSTRING(prd_key,7,LEN(prd_key)), '-', '_') AS prd_key,
	prd_nm,
	prd_cost,
	prd_line,
	prd_start_dt,
	prd_end_dt
FROM bronze.crm_prd_info
--WHERE REPLACE(SUBSTRING(prd_key,7,LEN(prd_key)), '-', '_') IN
--WHERE SUBSTRING(prd_key,7,LEN(prd_key)) IN 
--(SELECT sls_prd_key FROM bronze.crm_sales_details)


--Check for unwanted white spaces.
--TRIM command
--Result: no difference between the counts in the two queries.
--All row of the table are selected
SELECT
	COUNT(prd_nm)
FROM bronze.crm_prd_info

--Only the row with no differences in white spaces are selected.
SELECT
	COUNT(prd_nm)
FROM bronze.crm_prd_info
WHERE prd_nm = TRIM(prd_nm)

SELECT
	prd_id,
	prd_key,
	REPLACE(SUBSTRING(prd_key,1,5), '-', '_') AS cat_id,
	SUBSTRING(prd_key,7,LEN(prd_key)) AS prd_key,
	TRIM(prd_nm)
	prd_cost,
	prd_line,
	prd_start_dt,
	prd_end_dt
FROM bronze.crm_prd_info
--WHERE prd_nm = TRIM(prd_nm)


-- Check for NULLs or Negative Numbers.
-- Expectation: No Results
SELECT
	COUNT(prd_cost) AS product_cost
FROM bronze.crm_prd_info;

SELECT
	COUNT(prd_cost) AS product_cost
FROM bronze.crm_prd_info
WHERE prd_cost < 0;

SELECT
	COUNT(prd_cost) AS product_cost
FROM bronze.crm_prd_info
WHERE prd_cost IS NULL;

SELECT
	COUNT(prd_cost) AS product_cost
FROM bronze.crm_prd_info
WHERE prd_cost < 0 OR prd_cost IS NULL;

SELECT prd_cost AS product_cost
FROM bronze.crm_prd_info
WHERE prd_cost < 0 OR prd_cost IS NULL;

-- ISNULL()
-- Replaces NULL values with a specified replacement value.
-- You can use COALESCE as well

SELECT 
 ISNULL(prd_cost,0) AS prd_cost
FROM bronze.crm_prd_info
WHERE prd_cost < 0 OR prd_cost IS NULL;

SELECT
	prd_id,
	prd_key,
	REPLACE(SUBSTRING(prd_key,1,5), '-', '_') AS cat_id,
	SUBSTRING(prd_key,7,LEN(prd_key)) AS prd_key,
	TRIM(prd_nm),
	ISNULL(prd_cost,0) AS prd_cost,
	prd_line,
	prd_start_dt,
	prd_end_dt
FROM bronze.crm_prd_info


-- Data Standardization & Consistency
SELECT DISTINCT prd_line
FROM bronze.crm_prd_info


SELECT
	prd_line
	,CASE	WHEN UPPER(TRIM(prd_line)) = 'M' THEN 'Mountain' 
			WHEN UPPER(TRIM(prd_line)) = 'R' THEN 'Road'
			WHEN UPPER(TRIM(prd_line)) = 'S' THEN 'Other Sales'
			WHEN UPPER(TRIM(prd_line)) = 'T' THEN 'Touring'
	ELSE 'n/a'
	END AS prd_line
FROM bronze.crm_prd_info

--Quick CASE WHEN ideal for simple value mapping

SELECT
	prd_id,
	prd_key,
	REPLACE(SUBSTRING(prd_key,1,5), '-', '_') AS cat_id,
	SUBSTRING(prd_key,7,LEN(prd_key)) AS prd_key,
	TRIM(prd_nm),
	ISNULL(prd_cost,0) AS prd_cost,
	CASE UPPER(TRIM(prd_line))
		WHEN 'M' THEN 'Mountain' 
		WHEN 'R' THEN 'Road'
		WHEN 'S' THEN 'Other Sales'
		WHEN 'T' THEN 'Touring'
	ELSE 'n/a'
	END AS prd_line,
	prd_start_dt,
	prd_end_dt
FROM bronze.crm_prd_info

-- End date must not be earlier than the start date

-- Only select prd_start_dt
SELECT
prd_start_dt,
prd_end_dt
FROM bronze.crm_prd_info
WHERE 
	prd_start_dt IS NULL;

-- Only select prd_end_dt
SELECT
prd_start_dt,
prd_end_dt
FROM bronze.crm_prd_info
WHERE 
	prd_end_dt IS NULL;

-- Check for Invalid Date Orders
SELECT
prd_start_dt,
prd_end_dt
FROM bronze.crm_prd_info
WHERE 
	prd_end_dt < prd_start_dt;

-- For complex transformations in SQL, narrow it down to a 
-- specific example and brainstorm multiple solution approaches.


-- Switch End Date and Start Date
--End date must not be earlier than the start data.

--#1 Issue 
--Each Record must has a Start Date!
--This does not work because there are overlaps between records.

--#2 Solution 
--Derive the End Date from the Start Date.
--End Date = Start Date of the 'NEXT' Record - 1.
--LEAD() command to use to read a record within an exinting read.
--Access values from the next row wihtin a window.

SELECT
	prd_start_dt,
	prd_end_dt,
    LEAD(prd_start_dt) OVER (PARTITION BY prd_key ORDER BY prd_start_dt) - 1 AS prd_end_dt_test
FROM
    bronze.crm_prd_info
WHERE prd_key IN ('AC-HE-HL-U509-R', 'AC-HE-HL-U509');

-- prd_end_dt < prd_start_dt;



SELECT
prd_key,
prd_start_dt,
prd_end_dt
FROM bronze.crm_prd_info
WHERE
	prd_key LIKE '*HL*'; -- 'HL-U509-R';
--	AND	prd_end_dt < prd_start_dt;


--Complete code as so far 30 June 2025.
--Make the Data Time fields only Date with CAST command.
SELECT
	prd_id,
	prd_key,
	REPLACE(SUBSTRING(prd_key,1,5), '-', '_') AS cat_id,
	SUBSTRING(prd_key,7,LEN(prd_key)) AS prd_key,
	TRIM(prd_nm),
	ISNULL(prd_cost,0) AS prd_cost,
	CASE UPPER(TRIM(prd_line))
		WHEN 'M' THEN 'Mountain' 
		WHEN 'R' THEN 'Road'
		WHEN 'S' THEN 'Other Sales'
		WHEN 'T' THEN 'Touring'
	ELSE 'n/a'
	END AS prd_line,
	CAST (prd_start_dt AS DATE) AS prd_start_dt,
	CAST (LEAD(prd_start_dt) OVER (PARTITION BY prd_key ORDER BY prd_start_dt) - 1 AS DATE) AS prd_end_dt
FROM bronze.crm_prd_info

-- Derive Columns.
-- 	Create new columns based on calculations or
-- 	transformations of existing ones.
-- Data Enrichment
-- 	Add new, relevant data to enhance the dataset for analysis.
INSERT INTO silver.crm_prd_info(
  prd_id,
  cat_id,
  prd_key,
  prd_nm,
  prd_cost,
  prd_line,
  prd_start_dt,
  prd_end_dt)
SELECT
	prd_id,
	REPLACE(SUBSTRING(prd_key,1,5), '-', '_') AS cat_id, -- Extract category ID
	SUBSTRING(prd_key,7,LEN(prd_key)) AS prd_key,		 -- Extract product key
	TRIM(prd_nm),
	ISNULL(prd_cost,0) AS prd_cost, -- Replace none existing values by 0
	CASE UPPER(TRIM(prd_line)) -- Data normalization
		WHEN 'M' THEN 'Mountain' 
		WHEN 'R' THEN 'Road'
		WHEN 'S' THEN 'Other Sales'
		WHEN 'T' THEN 'Touring'
	ELSE 'n/a' --Instead of none existing data n/a "not available"
	END AS prd_line,
	CAST (prd_start_dt AS DATE) AS prd_start_dt, -- Convert data type to another data type 
	CAST (LEAD(prd_start_dt) OVER (PARTITION BY prd_key ORDER BY prd_start_dt) - 1 AS DATE) AS prd_end_dt -- Convert data type by enrichment
FROM bronze.crm_prd_info;

--Quality Check of the Loaded Data.

--Check for non unique product id's or missing.
--Expectation: No Results.
SELECT prd_id, count(*)
FROM silver.crm_prd_info
GROUP BY prd_id
HAVING COUNT(*) > 1 OR prd_id IS NULL;

--Check for white spaces.
--Expectation: No Results.
SELECT
	COUNT(prd_nm)
FROM bronze.crm_prd_info
WHERE prd_nm != TRIM(prd_nm);

--Check for NULLs or Negative Numbers.
--Expectation: No Results.
SELECT
	COUNT(prd_cost)
FROM silver.crm_prd_info
WHERE prd_cost < 0 OR prd_cost IS NULL;

SELECT prd_cost
FROM silver.crm_prd_info
WHERE prd_cost < 0 OR prd_cost IS NULL;

--Data Standardization & Consistency.
--Expectation: Complete Item Name and no NULLs.
SELECT DISTINCT prd_line
FROM silver.crm_prd_info

--Check for Invalid Date Orders
--Expectation: No Results.
SELECT
prd_start_dt,
prd_end_dt
FROM silver.crm_prd_info
WHERE 
	prd_end_dt < prd_start_dt;

--Check The Complete data in the Table
--Expectation: No Strange Data.
SELECT
*
FROM silver.crm_prd_info;



--Table: crm_sales_details
--Check for data.
--Expectation: No Results.
SELECT TOP (1000) [sls_ord_num]
      ,[sls_prd_key]
      ,[sls_cust_id]
      ,[sls_order_dt]
      ,[sls_ship_dt]
      ,[sls_due_dt]
      ,[sls_sales]
      ,[sls_quantity]
      ,[sls_price]
      ,[dwh_create_date]
  FROM [DataWarehouse].[silver].[crm_sales_details]

--Bronze layer table

--Check for unwanted spaces in the sls_ord_num field.
--Expectation: No Results.
SELECT TOP (1000) 
	sls_ord_num
   ,sls_prd_key
   ,sls_cust_id
   ,sls_order_dt
   ,sls_ship_dt
   ,sls_due_dt
   ,sls_sales
   ,sls_quantity
   ,sls_price
  FROM DataWarehouse.bronze.crm_sales_details
  WHERE sls_ord_num != TRIM(sls_ord_num);

--Relational field(s) from product key & customer ID.
--Check for missing foreign key values in the silver layer!

--Field: product key
--Expectation: No Results.
SELECT TOP (1000) 
	sls_ord_num
   ,sls_prd_key
   ,sls_cust_id
   ,sls_order_dt
   ,sls_ship_dt
   ,sls_due_dt
   ,sls_sales
   ,sls_quantity
   ,sls_price
  FROM DataWarehouse.bronze.crm_sales_details
  WHERE sls_prd_key NOT IN (SELECT prd_key FROM silver.crm_prd_info);

--Field: customer ID
--Expectation: No Results.
SELECT  
	sls_ord_num
   ,sls_prd_key
   ,sls_cust_id
   ,sls_order_dt
   ,sls_ship_dt
   ,sls_due_dt
   ,sls_sales
   ,sls_quantity
   ,sls_price
  FROM DataWarehouse.bronze.crm_sales_details
  WHERE sls_cust_id NOT IN (SELECT crm_cust_info.cst_id FROM silver.crm_cust_info);

--Convert the integers to a date format.

--Negative numbers or zeros can't be cast to a date.
--NULLIF() : Returns NULL if to given values are equal; otherwise, it return the first expression.

--Check that the 'Order Date' must always be earlier than the 'Shipping Date' or 'Due Date'.
SELECT  
	sls_ord_num
   ,sls_prd_key
   ,sls_cust_id
   ,sls_order_dt
   ,sls_ship_dt
   ,sls_due_dt
   ,sls_sales
   ,sls_quantity
   ,sls_price
  FROM DataWarehouse.bronze.crm_sales_details
  WHERE sls_order_dt > sls_ship_dt
	 OR sls_order_dt > sls_due_dt ;

--The fiels 'sls_order_dt' contains 0 values.
SELECT  
   sls_order_dt
   ,sls_ship_dt
   ,sls_due_dt
   FROM DataWarehouse.bronze.crm_sales_details
   WHERE sls_order_dt <= 0;

--Convert the 0 values to NULL
--In this scenario, the length of the date must be 8.
--Check for outliers by validating the bounderies of the date range.
--Check all date values with the same logic.
SELECT  
   NULLIF(sls_order_dt,0) sls_order_dt
   ,sls_ship_dt
   ,sls_due_dt
   FROM DataWarehouse.bronze.crm_sales_details
   WHERE sls_order_dt <= 0 --Convert only positive values
		OR LEN(sls_order_dt) != 8 --Convert only with 8 length values
		OR sls_order_dt > 25001231 --Do not convert higher out of bounderies values
		OR sls_order_dt < 19000101; --Do not convert lower out of bounderies values

--Apply the same integer conversion for all date fields.
SELECT  
	sls_ord_num
   ,sls_prd_key
   ,sls_cust_id
   ,CASE WHEN sls_order_dt = 0 OR LEN(sls_order_dt) != 8 THEN NULL
		 ELSE CAST(CAST(sls_order_dt AS VARCHAR) AS DATE)
	END AS sls_order_dt
   ,CASE WHEN sls_ship_dt = 0 OR LEN(sls_ship_dt) != 8 THEN NULL
		 ELSE CAST(CAST(sls_ship_dt AS VARCHAR) AS DATE)
	END AS sls_ship_dt
   ,CASE WHEN sls_due_dt = 0 OR LEN(sls_due_dt) != 8 THEN NULL
		 ELSE CAST(CAST(sls_due_dt AS VARCHAR) AS DATE)
	END AS sls_due_dt
   ,sls_sales
   ,sls_quantity
   ,sls_price
FROM DataWarehouse.bronze.crm_sales_details --;
WHERE sls_order_dt <= 0 --Convert only positive values
	OR LEN(sls_order_dt) != 8 --Convert only with 8 length values
	OR sls_order_dt > 25001231 --Do not convert higher out of bounderies values
	OR sls_order_dt < 19000101; --Do not convert lower out of bounderies values
  
--Check that the 'Order Date' must always be earlier than the 'Shipping Date' or 'Due Date'.
--Field: sls_order_dt
--Expectation: No Results.
SELECT 
*
FROM bronze.crm_sales_details
WHERE sls_order_dt > sls_ship_dt OR sls_order_dt > sls_due_dt;


--Business Rules
--Calculate: Sales = Quantity * Price
--Negative, Zeros, Nulls are Not Allowed!
--Check the Data Consistency in all Three Tables.

SELECT DISTINCT 
sls_sales
,sls_quantity
,sls_price
FROM bronze.crm_sales_details
WHERE sls_sales != sls_quantity * sls_price
	OR sls_sales <= 0 OR sls_sales IS NULL
	OR sls_quantity <= 0 OR sls_quantity IS NULL
	OR sls_price <= 0 OR sls_price IS NULL
ORDER BY sls_sales, sls_quantity, sls_price;

--Ask the system expert which solutions is recommened.
--#1 Solution
--Data Issues will be fixed direct in source system.
--#2 Solution
--Data Issues has to be fixed in data warehouse.

--Rules
--Build the transformation based on the following three rules.
--If Sales is negative, zero, or nul, derive it using Quantity and Price.
--If Price is zero or null, calculate it using Sales and Quantity.
--If PRice is negative, convert it to a positive value.

--ABS()
--Returns absolute value of a number.

SELECT DISTINCT
   CASE WHEN sls_sales <= 0
			 OR sls_sales != sls_quantity * ABS(sls_price) 
             OR sls_sales IS NULL
	THEN   sls_quantity * ABS(sls_price) 
	ELSE sls_sales
	END AS sls_sales
  ,CASE WHEN sls_price <= 0
		 OR sls_price IS NULL
	THEN sls_sales / NULLIF(sls_quantity,0)
	ELSE sls_price
	END AS sls_price
  ,CASE WHEN sls_quantity <= 0
		  OR sls_quantity IS NULL
	THEN   sls_sales / ABS(sls_price)
	ELSE sls_quantity
	END AS sls_quantity
FROM bronze.crm_sales_details
WHERE sls_sales != sls_quantity * sls_price
	OR sls_sales <= 0 OR sls_sales IS NULL
	OR sls_quantity <= 0 OR sls_quantity IS NULL
	OR sls_price <= 0 OR sls_price IS NULL
ORDER BY sls_sales, sls_quantity, sls_price;

--Modify the Table silver.crm_sales_details in the Silver Layer.
--Change the datatypes from INT to DATE.
--sls_order_dt DATE,
--sls_ship_dt  DATE,
--sls_due_dt   DATE,
IF OBJECT_ID('silver.crm_sales_details', 'U') IS NOT NULL
    DROP TABLE silver.crm_sales_details;
GO

CREATE TABLE silver.crm_sales_details (
    sls_ord_num  NVARCHAR(50),
    sls_prd_key  NVARCHAR(50),
    sls_cust_id  INT,
    sls_order_dt DATE,
    sls_ship_dt  DATE,
    sls_due_dt   DATE,
    sls_sales    INT,
    sls_quantity INT,
    sls_price    INT,
    dwh_create_date 	DATETIME2 DEFAULT GETDATE()
);
GO
--Insert the Bronze Layer Data into the Silver Layer Tables.

INSERT INTO silver.crm_sales_details(
	sls_ord_num
    ,sls_prd_key
    ,sls_cust_id
    ,sls_order_dt
    ,sls_ship_dt
    ,sls_due_dt
    ,sls_sales
    ,sls_quantity
    ,sls_price)
SELECT DISTINCT
	sls_ord_num
    ,sls_prd_key
    ,sls_cust_id
   ,CASE WHEN sls_order_dt = 0 OR LEN(sls_order_dt) != 8 THEN NULL
		 ELSE CAST(CAST(sls_order_dt AS VARCHAR) AS DATE)
	END AS sls_order_dt
   ,CASE WHEN sls_ship_dt = 0 OR LEN(sls_ship_dt) != 8 THEN NULL
		 ELSE CAST(CAST(sls_ship_dt AS VARCHAR) AS DATE)
	END AS sls_ship_dt
   ,CASE WHEN sls_due_dt = 0 OR LEN(sls_due_dt) != 8 THEN NULL
		 ELSE CAST(CAST(sls_due_dt AS VARCHAR) AS DATE)
	END AS sls_due_dt
   ,CASE WHEN sls_sales <= 0
			 OR sls_sales != sls_quantity * ABS(sls_price) 
             OR sls_sales IS NULL
	THEN   sls_quantity * ABS(sls_price) 
	ELSE sls_sales
	END AS sls_sales
  ,CASE WHEN sls_price <= 0
		 OR sls_price IS NULL
	THEN sls_sales / NULLIF(sls_quantity,0)
	ELSE sls_price
	END AS sls_price
  ,CASE WHEN sls_quantity <= 0
		  OR sls_quantity IS NULL
	THEN   sls_sales / ABS(sls_price)
	ELSE sls_quantity
	END AS sls_quantity
FROM bronze.crm_sales_details;

--The WHERE Condition is not needed when Loading the Data because CASE Statements are used.
WHERE sls_order_dt <= 0 --Convert only positive values
	OR LEN(sls_order_dt) != 8 --Convert only with 8 length values
	OR sls_order_dt > 25001231 --Do not convert higher out of bounderies values
	OR sls_order_dt < 19000101 --Do not convert lower out of bounderies values
	OR sls_sales != sls_quantity * sls_price
	OR sls_sales <= 0 OR sls_sales IS NULL
	OR sls_quantity <= 0 OR sls_quantity IS NULL
	OR sls_price <= 0 OR sls_price IS NULL
ORDER BY sls_sales, sls_quantity, sls_price;

--Quality Check of the Loaded Data in the Silver Table.

--Check for order date is not before ship or due date.
--Expectation: No Results.
SELECT 
*
FROM silver.crm_sales_details
WHERE sls_order_dt > sls_ship_dt OR sls_order_dt > sls_due_dt;

--Check that all transformations are correct processed.
--Expectation: No Results.

SELECT DISTINCT 
sls_sales
,sls_quantity
,sls_price
FROM silver.crm_sales_details
WHERE sls_sales != sls_quantity * sls_price
	OR sls_sales <= 0 OR sls_sales IS NULL
	OR sls_quantity <= 0 OR sls_quantity IS NULL
	OR sls_price <= 0 OR sls_price IS NULL
ORDER BY sls_sales, sls_quantity, sls_price;

--Check that all rows are correct processed.
--Expectation: All Rows.

SELECT 
*
FROM silver.crm_sales_details;
